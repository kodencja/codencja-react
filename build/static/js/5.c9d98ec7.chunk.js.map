{"version":3,"sources":["componentsHook/WriteText.jsx","componentsHook/About.jsx"],"names":["WriteText","props","textAppearStart","pauseBetweenNewSentenceAppear","pauseAfterAllTextsDisplayed","pauseBeforeOneSubTitleSentenceFadeOut","timeToDisplayText1","timeToDisplayText2","mainTitle","subTitles","useStateAsync","currentSubTitle","setCurrentSubTitle","useState","spanSubChange","setSpanSubChange","mainTxtShown","useRef","subTxtCurrentIndex","mainTxtRef","subTxtRef","spanMainTitleRef","spanSubTitleRef","useEffect","console","log","display","current","length","subTitleAddRef","el","includes","push","mainTitleAddRef","spanTab","i","iSubTab","classList","contains","remove","displayOneSentence","setTimeout","a","add","forEach","span","$","css","time","mainTitleSpans","useMemo","map","letter","ind","style","visibility","ref","subTitleSpans","subTitleArray","className","About","Fragment","React","memo"],"mappings":"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","file":"static/js/5.c9d98ec7.chunk.js","sourcesContent":["import React, { useRef, useEffect, useState, useMemo } from \"react\";\r\nimport $ from \"jquery\";\r\nimport useStateAsync from \"./customHooks/useStateAsync\";\r\n\r\nfunction WriteText(props) {\r\n  const {\r\n    textAppearStart,\r\n    pauseBetweenNewSentenceAppear,\r\n    pauseAfterAllTextsDisplayed,\r\n    pauseBeforeOneSubTitleSentenceFadeOut,\r\n    timeToDisplayText1,\r\n    timeToDisplayText2,\r\n    mainTitle,\r\n    subTitles,\r\n  } = props;\r\n  // currentSubTitle - musi być w useState a nie w useRef, bo jego zmiana musi wyrenderować nowe zdanie w jsx\r\n  const [currentSubTitle, setCurrentSubTitle] = useStateAsync(\"\", 1000);\r\n  const [spanSubChange, setSpanSubChange] = useState(false);\r\n\r\n  const mainTxtShown = useRef(false);\r\n\r\n  const subTxtCurrentIndex = useRef(0);\r\n\r\n  // mainTxtRef - reference to the div embracing the mainTitle within spanMainTitleRef.current\r\n  const mainTxtRef = useRef();\r\n\r\n  // subTxtRef - reference to the div embracing the currentSubTitle within spanSubTitleRef.current\r\n  const subTxtRef = useRef();\r\n\r\n  // reference array to mainTitle 's each letter embraced around span\r\n  const spanMainTitleRef = useRef([]);\r\n\r\n  // reference array to currentSubTitle 's each letter embraced around span\r\n  const spanSubTitleRef = useRef([]);\r\n\r\n  useEffect(() => {\r\n    console.log(\"WriteText Comp. mounted!\");\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (textAppearStart === true) {\r\n      // console.log(\"useEffect spanMainTitleRef\");\r\n      display(spanMainTitleRef.current, 0, subTxtCurrentIndex.current);\r\n    }\r\n  }, [textAppearStart]);\r\n\r\n  useEffect(() => {\r\n    if (mainTxtShown.current === true && spanSubTitleRef.current.length > 0) {\r\n      display(spanSubTitleRef.current, 0, subTxtCurrentIndex.current);\r\n    }\r\n  }, [spanSubChange]);\r\n\r\n  const subTitleAddRef = (el) => {\r\n    if (el && el !== null && !spanSubTitleRef.current.includes(el)) {\r\n      // console.log(\"subTitleAddRef Fn\");\r\n      spanSubTitleRef.current.push(el);\r\n    }\r\n  };\r\n\r\n  const mainTitleAddRef = (el) => {\r\n    if (el && el !== null && !spanMainTitleRef.current.includes(el)) {\r\n      spanMainTitleRef.current.push(el);\r\n    }\r\n  };\r\n  //   },\r\n  //   [spanMainTitleRef]\r\n  // );\r\n\r\n  // spanTab - spanMainTitleRef or spanSubTitleRef\r\n  // iSubTab - subTxtCurrentIndex\r\n  const display = (spanTab, i, iSubTab) => {\r\n    if (subTxtRef.current.classList.contains(\"fadeOutFast\")) {\r\n      subTxtRef.current.classList.remove(\"fadeOutFast\");\r\n    }\r\n    if (subTxtRef.current.classList.contains(\"fadeOut\")) {\r\n      subTxtRef.current.classList.remove(\"fadeOut\");\r\n    }\r\n    if (mainTxtRef.current.classList.contains(\"fadeOut\")) {\r\n      mainTxtRef.current.classList.remove(\"fadeOut\");\r\n    }\r\n\r\n    // if the mainTitle has not been displayed yet\r\n    if (mainTxtShown.current === false) {\r\n      if (i < spanTab.length) {\r\n        displayOneSentence(spanTab, i, iSubTab, timeToDisplayText1);\r\n      } else {\r\n        // set current index of the span array to 0\r\n        i = 0;\r\n        mainTxtShown.current = true;\r\n        setTimeout(async () => {\r\n          await setCurrentSubTitle(\r\n            subTitles[subTxtCurrentIndex.current],\r\n            currentSubTitle\r\n          );\r\n        }, pauseBetweenNewSentenceAppear);\r\n      }\r\n    }\r\n    // if the mainTitle has already been displayed\r\n    else {\r\n      // if index of the particular sentence from subTitle array has not reached its last element\r\n      if (i < spanTab.length) {\r\n        displayOneSentence(spanTab, i, iSubTab, timeToDisplayText2);\r\n      }\r\n      // if index of the particular sentence from subTitle array has reached its last element (letter)\r\n      else {\r\n        subTxtCurrentIndex.current++;\r\n        // here we have to clear spanSubTitleRef.current since another spans with another letter will have to be stored in this reference\r\n        spanSubTitleRef.current = [];\r\n\r\n        // if index of the subTitles array HAS NOT reached its last element (sentence) = if index of the subTitles array is less or equal to its last element (sentence)\r\n        if (subTxtCurrentIndex.current < subTitles.length) {\r\n          setTimeout(() => {\r\n            subTxtRef.current.classList.add(\"fadeOutFast\");\r\n            setTimeout(async () => {\r\n              spanTab.forEach((span) => {\r\n                $(span).css(\"visibility\", \"hidden\");\r\n              });\r\n              await setCurrentSubTitle(\r\n                subTitles[subTxtCurrentIndex.current],\r\n                currentSubTitle\r\n              );\r\n            }, pauseBetweenNewSentenceAppear / 2);\r\n          }, pauseBeforeOneSubTitleSentenceFadeOut);\r\n        }\r\n\r\n        // if index of the subTitles array HAS REACHED its last element (sentence) - so what to do next\r\n        else {\r\n          setTimeout(() => {\r\n            mainTxtRef.current.classList.add(\"fadeOut\");\r\n            subTxtRef.current.classList.add(\"fadeOut\");\r\n            subTxtCurrentIndex.current = 0;\r\n            mainTxtShown.current = false;\r\n\r\n            setTimeout(() => {\r\n              spanTab.forEach((span) => {\r\n                $(span).css(\"visibility\", \"hidden\");\r\n              });\r\n              spanMainTitleRef.current.forEach((span) => {\r\n                $(span).css(\"visibility\", \"hidden\");\r\n              });\r\n\r\n              setTimeout(() => {\r\n                display(\r\n                  spanMainTitleRef.current,\r\n                  0,\r\n                  subTxtCurrentIndex.current\r\n                );\r\n              }, pauseBetweenNewSentenceAppear);\r\n            }, pauseBetweenNewSentenceAppear);\r\n          }, pauseAfterAllTextsDisplayed);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  const displayOneSentence = (spanTab, i, iSubTab, time) => {\r\n    setTimeout(() => {\r\n      $(spanTab[i]).css(\"visibility\", \"visible\");\r\n      i++;\r\n      display(spanTab, i, iSubTab);\r\n    }, time);\r\n  };\r\n\r\n  // mainTitle divided into each letter embraced around span\r\n  const mainTitleSpans = useMemo(() => {\r\n    return [...mainTitle].map((letter, ind) => {\r\n      return (\r\n        <span\r\n          style={\r\n            mainTxtShown.current === false\r\n              ? { visibility: \"hidden\" }\r\n              : { visibility: \"visible\" }\r\n          }\r\n          key={ind}\r\n          ref={mainTitleAddRef}\r\n        >\r\n          {letter}\r\n        </span>\r\n      );\r\n    });\r\n  }, [mainTitle]);\r\n\r\n  // currentSubTitle divided into each letter embraced around span\r\n  const subTitleSpans = useMemo(() => {\r\n    if (currentSubTitle.length > 0) {\r\n      const subTitleArray = [...currentSubTitle].map((letter, ind) => {\r\n        return (\r\n          <span style={{ visibility: \"hidden\" }} key={ind} ref={subTitleAddRef}>\r\n            {letter}\r\n          </span>\r\n        );\r\n      });\r\n\r\n      // ta poniższa linia uruchamia ciąg wyświetlania subTitles\r\n      // setSpanSubChange - let spanSubTitleRef.current to be filled out only after currentSubTitle and consequently  subTitleSpans have changed, not earlier\r\n      setSpanSubChange(!spanSubChange);\r\n      return subTitleArray;\r\n    } else {\r\n      return null;\r\n    }\r\n  }, [currentSubTitle]);\r\n\r\n  return (\r\n    <div className=\"row justify-content-left cont-about-me about-me align-left\">\r\n      <div\r\n        className=\"text1 row-text1 col-sm-10 mb-4 h1 animated \"\r\n        ref={mainTxtRef}\r\n      >\r\n        {mainTitleSpans}\r\n      </div>\r\n      <div\r\n        className=\"text2 row-text2 col-sm-10 mb-4 h2 animated \"\r\n        ref={subTxtRef}\r\n      >\r\n        {subTitleSpans}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default WriteText;\r\n","import React, { useEffect } from \"react\";\r\n// import phI from \"../img/ja_odb4-2.jpg\";\r\nimport WriteText from \"./WriteText\";\r\nimport \"../css/about.css\";\r\n\r\nconst aboutTitle = \"ABOUT ME\";\r\nconst mainTitle = \"Krzysztof Lalik\";\r\nconst subTitles = [\r\n  \"Front-end Developing\",\r\n  \"Back-end Supporting\",\r\n  \"Programming & designing websites\",\r\n  \"Fully responsive & interactive\",\r\n  \"Individuals & Companies\",\r\n  \"Sync & Async\",\r\n  \"MVC Pattern\",\r\n  \"Desktop, Tablet, Mobile\",\r\n];\r\n\r\nconst About = (props) => {\r\n  const { textAppearStart } = props;\r\n\r\n  useEffect(() => {\r\n    console.log(\"About Comp. mounted\");\r\n  }, []);\r\n\r\n  return (\r\n    <React.Fragment>\r\n      <header className=\"title sec-title title-col-bright title-bgr-dark-bright-grad\">\r\n        {aboutTitle}\r\n      </header>\r\n      <div className=\"container sec-cont\">\r\n        <WriteText\r\n          textAppearStart={textAppearStart}\r\n          pauseBetweenNewSentenceAppear={1200}\r\n          pauseAfterAllTextsDisplayed={1800}\r\n          pauseBeforeOneSubTitleSentenceFadeOut={800}\r\n          timeToDisplayText1={180}\r\n          timeToDisplayText2={100}\r\n          mainTitle={mainTitle}\r\n          subTitles={subTitles}\r\n        />\r\n      </div>\r\n    </React.Fragment>\r\n  );\r\n};\r\n\r\nexport default React.memo(About);\r\n"],"sourceRoot":""}